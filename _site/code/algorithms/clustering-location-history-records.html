<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Clustering location history records: How and Why</title>
  <meta name="description" content="MotivationIf you have an Android phone with location services turned on, whenever your phone is connected to the Internet it sends location history records t...">

  <link rel="stylesheet" href="/posts/css/main.css">
  <link rel="canonical" href="http://kylebebak.github.io/posts/code/algorithms/clustering-location-history-records">
  <link rel="alternate" type="application/rss+xml" title="dronfelipe" href="http://kylebebak.github.io/posts/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/posts/">dronfelipe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="/posts/site-map">Map</a>
        <a class="page-link" href="/posts/about">About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Clustering location history records: How and Why</h1>
    <p class="post-meta"><time datetime="2015-12-03T00:00:00-06:00" itemprop="datePublished">Dec 3, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="motivation">Motivation</h2>
<p>If you have an Android phone with location services turned on, whenever your phone is connected to the Internet it sends <strong>location history records</strong> to Google’s servers, one per minute. This is true of Microsoft’s and Apple’s phones as well. These records contain three important fields: <code class="highlighter-rouge">latitude</code>, <code class="highlighter-rouge">longitude</code>, and <code class="highlighter-rouge">timestamp</code>. If your phone is usually with you, these records give a very complete picture of where you were at any time in the past.</p>

<p>Their usefulness, however, is limited by their number: location history is <strong><em>too detailed</em></strong>. In a year your phone will send 500,000 records to be saved in a database. Executing queries on millions of records to uncover patterns is difficult for both users and hardware. What’s worse is that the records are semantically identical. We know intuitively that 600 consecutive records with the same geographic coordinates represent something very different from a sequence of 30 records starting at home and ending at work, so we need a classification that makes this clear.</p>

<p>This is where clustering comes in. It accomplishes two important goals:</p>

<ul>
  <li>compresses the data</li>
  <li>groups records into distinct, meaningful entities</li>
</ul>

<p>I’ll describe these entities to explain the basic idea, then I’ll look at the algorithm to show that the clustering is simple, fast, and predictable. At the end I’ll talk about some applications.</p>

<h2 id="visits-trips-and-locations">Visits, Trips and Locations</h2>
<p>We return to the intuition that a sequence of records in the same location are different from a sequence that starts at A and ends at B. Our first logical entity, then, will serve to group consecutive stationary records into visits. Specifically, a <strong><code class="highlighter-rouge">visit</code></strong> is a sequence of <code class="highlighter-rouge">N</code> or more records separated by no more than a distance <code class="highlighter-rouge">R</code>. A visit knows its <code class="highlighter-rouge">lat</code>, <code class="highlighter-rouge">lon</code>, <code class="highlighter-rouge">start_time</code>, and <code class="highlighter-rouge">end_time</code>.</p>

<p>A sequence of records which is not stationary and cannot be grouped into a visit is necessarily grouped into a <strong><code class="highlighter-rouge">trip</code></strong> between two visits. Every pair of consecutive visits is connected by a trip. A trip knows its <code class="highlighter-rouge">displacement</code>, <code class="highlighter-rouge">distance</code>, <code class="highlighter-rouge">start_time</code>, <code class="highlighter-rouge">end_time</code>, <code class="highlighter-rouge">start_visit</code>, and <code class="highlighter-rouge">end_visit</code>. By giving the trip pointers to the first and last location history records from which it was formed, these records can be used to reconstruct the trip’s route if necessary.</p>

<p>The last entity we define allows us to cluster visits <em>(and hence trips, which are defined in terms of their start and end visits)</em> into groups. We define a <strong><code class="highlighter-rouge">location</code></strong> as the average latitude and longitude of a group of visits separated by no more than a distance <code class="highlighter-rouge">R</code>, the same R that we used for clustering records into visits. The motivation is simple: locations allow us to see hundreds of otherwise distinct visits as belonging to the same equivalence class, e.g. visits to <strong>home</strong>, or visits to <strong>work</strong>. They also group trips into equivalence classes, e.g. trips <strong>from home to work</strong>, or <strong>from work to home</strong>.</p>

<p>Assigning locations to visits and trips allows us to answer aggregate questions, like:</p>

<ul>
  <li>Where do I spend most of my time (top 5 places) on Saturdays?</li>
  <li>How many times have I been to my girlfriend’s house, on the weekend?</li>
  <li>Over the past 6 months, at what time on average do I leave work on Friday?</li>
  <li>How long on average does it take me to get to work?</li>
</ul>

<p>When run on 18 months (~750,000 records) of my location history, this process turned up 4,400 visits (and hence 4,400 trips) belonging to 750 locations. I used <code class="highlighter-rouge">N=6, R=10m</code> as clustering parameters, meaning that 6 minutes or more spent in the same 10 meter radius was considered a visit. 750,000 records were thus transformed into 10,000 vastly more expressive ones.</p>

<h2 id="clustering-algorithm">Clustering Algorithm</h2>
<p>Without constraints, clustering spatial data is a hard problem with imprecise solutions. Even using heuristics it’s hard to beat quadratic time complexity, the intuition being that to assign each record to a cluster, you need to compare it with all the other records in the set to know which ones are nearby.</p>

<p>However, when clustering location history records we exploit the fact that the <strong>distance</strong> metric by which we define <strong>nearness</strong> includes <strong><em>time</em></strong>. We only group records that occur within a small span of time, and because we can sort the records by timestamp (indeed, they’re already sorted for us), independent of geographic coordinates, we can get the clustering done in <strong><em>linear</em></strong> time.</p>

<p>We also exploit our classification scheme: we are looking for an alternating sequence of visits and trips. We know what the visits look like, and <em>we don’t even need to find the trips.</em> Every trip is bookended by a pair of visits, so once we have the visits we simply read through the unclustered records that connect them and instantiate our trips.</p>

<p>Here’s how it works. In the first pass through the data, each record is compared to the most recently instantiated <strong>potential visit</strong>, whose latitude and longitude are the average coordinates of the records it contains. If the record is within a distance <code class="highlighter-rouge">R</code> of the visit, it gets added to the visit, and the visit’s latitude and longitude are recalculated to reflect the addition of the record. If the record is not within <code class="highlighter-rouge">R</code> of the visit, a new potential visit is instantiated containing only this record. In Python:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">visit</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">for</span> <span class="n">each</span> <span class="n">record</span> <span class="ow">in</span> <span class="n">records</span><span class="p">:</span>
<span class="c"># records sorted from oldest to newest</span>
  <span class="k">if</span> <span class="n">visit</span> <span class="ow">and</span> <span class="n">visit</span><span class="o">.</span><span class="n">distance_to</span><span class="p">(</span><span class="n">record</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>
    <span class="n">visit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">visit</span> <span class="o">=</span> <span class="n">Visit</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
</code></pre>
</div>

<p>Next, potential visits with fewer than <code class="highlighter-rouge">N</code> constituent records are discarded. The remaining visits have pointers to their first and last records, which allows the second pass through the data to focus only on the unclustered records. From each sequence of records linking one visit to another, a trip is instantiated.</p>

<p>A third pass, this time through the visits, generates locations. We compare each visit to all existing locations, and add it to the first location within distance <code class="highlighter-rouge">R</code> of the visit. We recompute this location’s latitude and longitude as the average coordinates of the visits it contains, <strong><em>weighted by the duration of these visits</em></strong>. If no nearby location exists, we instantiate a new location containing only this visit.</p>

<h2 id="discussion">Discussion</h2>
<p>Depending on implementation, the clustering is deterministic: in any case, the only way to significantly change the results is to tweak the parameters <code class="highlighter-rouge">N</code> and <code class="highlighter-rouge">R</code>. Fortunately, the effects of these parameters are predictable. Increasing <code class="highlighter-rouge">N</code> causes shorter visits to disappear, and increasing <code class="highlighter-rouge">R</code> makes some visits slightly longer, and causes some adjacent locations to be merged.</p>

<p>Exploiting structure and constraints inherent in the data, we avoid the guesswork used in algorithms like <strong>k-means</strong>, resulting in a simple, predictable algorithm that produces clusters whose meaning is clear. As for time complexity, any conceivable clustering will have to read each record at least once, so our linear implementation, at least for clustering visits, is <em>as fast as possible</em>.</p>

<p>An aside: it seems plausible that a sequence of unfortunately placed records, moving slowly but surely in one direction, could <strong>“stretch out”</strong> a visit so that it contains pairs of records that are separated by a distance much greater than <code class="highlighter-rouge">R</code>. <a href="/posts/sub-pages/visit-logarithmic-growth">I’ve shown here</a> that for the most pathological sequence of records, the <strong>“diameter”</strong> of the visit grows as <code class="highlighter-rouge">R * ln(n)</code>, where <code class="highlighter-rouge">n</code> is the number of records in the visit. With real data, stretched visits occur with vanishing probability. Still, it’s reassuring that even in the worst case they grow slowly.</p>

<p>Another aside: because locations have no temporal component, we can’t exploit time in our distance metric to decrease the number of comparisons we make to instantiate them. However, these comparisons are made between visits and locations, not between pairs of records. Comparing 4,400 visits to 750 locations is <strong><em>much less expensive</em></strong> than doing pairwise comparison between 750,000 records. If these comparisons become costly, we can always consider other techniques for finding neighbors, like <a href="http://www.bigfastblog.com/geohash-intro">geohashing</a>.</p>

<h2 id="applications">Applications</h2>
<p>Visits and trips give a good account of your movements, and even some of your habits, but this story can be enriched by knowing <strong><em>what</em></strong> you’re doing and <strong><em>with whom</em></strong>, instead of just where you’re going. Google, for example, is in a good position to generate these stories. With the <a href="https://developers.google.com/maps/documentation/geocoding/intro#ReverseGeocoding">Geocoding API</a>, addresses can be looked up for geographical coordinates, so that automatic descriptions and photos are generated for your locations.</p>

<p>If you take pictures and use Google Photos, these could be linked to the visits or trips on which they were taken. If you go to a store, or a restaurant, or a museum, you are probably visiting a location for which Google has records and metadata, and your location instance could be a given a pointer to theirs. Suppose you use Google Wallet, or have your bank account configured to send you transaction alerts via text message. Financial transactions could be attached to the visits on which they occur.</p>

<p>Most importantly, visits, trips and locations point to the users that generate them, and this is where social networking comes into play. Imagine you <strong>“friend”</strong> another user. Your visits that <strong>“overlap”</strong> spatially and temporally with theirs could automatically be <strong>“shared”</strong> between you, so that you could look at photos, comments, or whatever else your friends add to these visits. You could look at a location and see the list of friends who shared a visit there with you, then select one of these friends and see the list of visits you shared with them. And so on.</p>

<h2 id="privacy">Privacy</h2>
<p>For allowing users to track themselves in the privacy of their own phones, it’s easy to write a client-side application to cluster and store location history records. But part of the tradition of the web is users trading privacy for convenience, or simply for the opposite of privacy. I think the networking features of location history, which can’t be implemented client-side, will be embraced by users in the future. I wrote this clustering program, and built a front end for <a href="http://www.dronfelipe.com/location_history/">exploring the results</a>, in 2014. Google probably thought of it before that, but didn’t release <a href="https://www.google.com/maps/timeline">Timeline</a> until 2015, because it’s an idea that <a href="http://venturebeat.com/2015/07/27/hands-on-with-google-maps-your-timeline-fascinating-but-freaky/">gives us pause</a>. We need to get comfortable tracking ourselves before we are tracked by our friends.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">dronfelipe</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>dronfelipe</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kylebebak"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">kylebebak</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/KyleBebak"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">KyleBebak</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
          Code, TILs, and other stuff.
Everything in this blog is licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
        </p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
