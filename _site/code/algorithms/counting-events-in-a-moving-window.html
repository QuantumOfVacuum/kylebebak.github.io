<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Counting Events in a Moving Time Window</title>
  <meta name="description" content="Detecting AnomaliesImagine you’re writing a program that reads a series of transactions in real time, and raises an alert whenever more than 50 occur in an h...">

  <link rel="stylesheet" href="/posts/css/main.css">
  <link rel="canonical" href="http://kylebebak.github.io/posts/code/algorithms/counting-events-in-a-moving-window">
  <link rel="alternate" type="application/rss+xml" title="dronfelipe" href="http://kylebebak.github.io/posts/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/posts/">dronfelipe</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        <a class="page-link" href="/posts/site-map">Map</a>
        <a class="page-link" href="/posts/about">About</a>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Counting Events in a Moving Time Window</h1>
    <p class="post-meta"><time datetime="2014-09-20T00:00:00-05:00" itemprop="datePublished">Sep 20, 2014</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h2 id="detecting-anomalies">Detecting Anomalies</h2>
<p>Imagine you’re writing a program that reads a series of transactions in real time, and raises an alert whenever more than 50 occur in an hour. Or whenever the total value of these transactions exceeds 500 dollars. Full disclosure: I did this for a big client in Mexico that wanted to detect fraudulent transactions in their stores, both for issuing real-time alerts and for reviewing historical data. I’m not sure whether stores in the U.S. worry about this, but in any case this sort of problem gives rise to an interesting programming model called <a href="https://en.wikipedia.org/wiki/Discrete_event_simulation">discrete event simulation</a>.</p>

<p>This post doesn’t explain DES — there are good explanations on the web, for example <a href="http://algs4.cs.princeton.edu/61event/">this one</a>. But here’s the gist of it: DES contrasts with <strong>continuous simulation</strong> by only examining and updating the state of the system when an event occurs. This model is perfectly suited for the counting problem, which is one of the simplest problems DES can address.</p>

<h2 id="the-not-moving-window">The (Not) Moving Window</h2>
<p>Let’s say the transactions (henceforth events) of the previous month are in a relational database. As above, we want to flag every instance in which there were more than 50 events in an hour. One approach is to select the count of events and group them by hour, but this is flawed. <strong>Let’s say between 10 and 10:30 there are no events, and between 10:30 and 11 there are forty. Between 11 and 11:30 there are forty more, and again there are none between 11:30 and 12.</strong> The query would flag neither 10-11 nor 11-12 as suspicious, because the number of events in both hours is below the threshold. But the query would fail to notice that between 10:30 and 11:30 there were eighty events, and the threshold was exceeded.</p>

<p>Clearly, we can’t group by hour to count events. We need more precision, so we consider the following: for each event, we take its timestamp <code class="highlighter-rouge">T</code> and select the count of events that fall between <code class="highlighter-rouge">T</code> and <code class="highlighter-rouge">T + 1h</code>. This will definitely work, but it requires one query per event. This is infeasible if there are lots of events.</p>

<p>But this inefficient solution leads to an insight. <strong>Namely, we need an hour-long <em>“window”</em> through which we can examine blocks of consecutive events.</strong> But instead of moving the window forward, event by event, we can stream the events through the window. This allows us to see when the threshold is exceeded, but issues <strong>just one query</strong> to the database. It turns out a queue is the ideal structure for this “stationary” window.</p>

<h2 id="using-the-queue">Using the Queue</h2>
<p>The algorithm is dead simple. We stream the events out of the database and enqueue them in chronological order. As we enqueue each event, we compare it to the event on the front of the queue (the oldest event on the queue). If the difference in their timestamps is more than <code class="highlighter-rouge">1h</code>, we dequeue the oldest event. We repeat this process until the oldest event on the queue is within <code class="highlighter-rouge">1h</code> of the newest event of the queue. After this, we just count the events on the queue, <strong>because they all occurred within a span of one hour</strong>. If the count exceeds 50, well, you get the idea. Also, if we want to find hour-long intervals where the count is <strong>below</strong> 50, we just reverse our inequality. Here’s what the code looks like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">flagged_events</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
  <span class="n">q</span><span class="o">.</span><span class="n">enqueue</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="c"># newest event is on back of queue</span>
  <span class="k">while</span> <span class="n">q</span><span class="o">.</span><span class="n">back</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">q</span><span class="o">.</span><span class="n">front</span><span class="p">()</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">interval</span><span class="p">:</span>
    <span class="n">q</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
    <span class="n">flagged_events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</code></pre>
</div>

<h2 id="performance">Performance</h2>
<p>Any approach to solving this problem will need to look at all the events. To understand the performance of our approach, we consider that the queue is empty at the beginning, and is nearly empty (just one event remains) at the end.</p>

<p>On average then, for every event that goes on the queue, one comes off. So, for an <strong>average iteration</strong> of the algorithm, we look at <strong>three events</strong>: the new one that goes on the back of the queue, the oldest one at the front of the queue (which usually gets dequeued), and the second oldest one (which usually doesn’t get dequeued). We are reading <code class="highlighter-rouge">3N</code> events and making <code class="highlighter-rouge">2N</code> comparisons to process <code class="highlighter-rouge">N</code> events, which means our approach is <strong>linear</strong> in the number of events.</p>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">dronfelipe</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>dronfelipe</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/kylebebak"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">kylebebak</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/KyleBebak"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">KyleBebak</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>
          Code, TILs, and other stuff.
Everything in this blog is licensed under the <a href="https://opensource.org/licenses/MIT">MIT License</a>.
        </p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
